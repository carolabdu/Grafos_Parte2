 
2. Distâncias com pesos negativos 
     Apenas retornar que não é possível
3. Distância = Djkstra???
      Sim, já testada  e caminho já testado tb (:
4. Tem que usar as duas formas de representação??
      Pode usar apenas uma forma de representação

5. Para calcular a distância de forma mais eficiente, podemos verificar se o grafo é esparso e escolher se usaremos Dijkstra com ou sem heap. 


import time
import random

grafo = Graph_l(vertices, arestas)

tempo_djk = 0
tempo_heap = 0 

for i in range(20):
    vertice = random.randint(1,grafo.v)
    
    inicio_djk = time.time()
    grafo.DijkstraHeap(vertice,0)
    fim_djk = time.time()

    inicio_heap = time.time()
    grafo.Dijkstra(vertice,0)
    fim_heap = time.time()
    
    tempo_djk += fim_djk - inicio_djk
    tempo_heap += fim_heap - inicio_heap

print ('Tempo sem heap:', tempo_djk/20, 'Tempo com heap:', tempo_heap/20)
